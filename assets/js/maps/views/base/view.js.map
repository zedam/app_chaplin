{"version":3,"sources":["views/base/view.coffee"],"names":[],"mappings":"AAAA,IAAA;;;AAAA,MAAA,CAAO,CACL,YADK,EAEL,SAFK,EAGL,iBAHK,CAAP,EAIG,SAAC,UAAD,EAAa,OAAb;EACD;AAAA,MAAA;SAEM;;;;;;;mBACJ,mBAAA,GAAqB,SAAA;AAiBnB,UAAA;MAAA,QAAA,GAAW,IAAC,CAAA;MAEZ,IAAG,OAAO,QAAP,KAAmB,QAAtB;QAIE,YAAA,GAAe,UAAU,CAAC,OAAX,CAAmB,QAAnB;QACf,IAAC,CAAA,WAAW,CAAA,SAAE,CAAA,QAAd,GAAyB,aAL3B;OAAA,MAAA;QAOE,YAAA,GAAe,SAPjB;;aASA;IA5BmB;;;;KADJ,OAAO,CAAC;AAH1B,CAJH","file":"views/base/view.js","sourceRoot":"/source/","sourcesContent":["define [\n  'handlebars'\n  'chaplin'\n  'lib/view-helper' # Just load the view helpers, no return value\n], (Handlebars, Chaplin) ->\n  'use strict'\n\n  class View extends Chaplin.View\n    getTemplateFunction: ->\n      # Template compilation\n      # --------------------\n\n      # This demo uses Handlebars templates to render views.\n      # The template is loaded with Require.JS and stored as string on\n      # the view prototype. On rendering, it is compiled on the\n      # client-side. The compiled template function replaces the string\n      # on the view prototype.\n      #\n      # In the end you might want to precompile the templates to JavaScript\n      # functions on the server-side and just load the JavaScript code.\n      # Several precompilers create a global JST hash which stores the\n      # template functions. You can get the function by the template name:\n      #\n      # templateFunc = JST[@templateName]\n\n      template = @template\n\n      if typeof template is 'string'\n        # Compile the template string to a function and save it\n        # on the prototype. This is a workaround since an instance\n        # shouldnâ€™t change its prototype normally.\n        templateFunc = Handlebars.compile template\n        @constructor::template = templateFunc\n      else\n        templateFunc = template\n\n      templateFunc\n"]}